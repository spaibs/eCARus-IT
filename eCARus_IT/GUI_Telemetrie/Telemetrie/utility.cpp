
/*
    utility.cpp

    Contains utility functions

    Author: Michael Manhart <m.manhart@tum.de>

*/
#include <QString>
#include "utility.h"
#include "datatypes.h"
#include "udpthread.h"

namespace utility
{
int	HexStringToCharArray (std::string &string, unsigned char* array, int string_size, int array_size)
{
    /*
            Converts a string (wchar_t) that contains a hexadecimal number to a
            array of chars (with contain the hexadecimal data)
            The lenght of the string has to be stored in string_size
            The lenght of the aim array has to be stored in size
            If the string is not long enough to fill the array it will be filled with zeros
            The array with the result has to be size big.
            The numbers from A to F have to be upper case.

            Example of conversation:
            String ABC123    string_size = 6 array_size = 4
            array[0] = AB
            array[1] = C1
            array[2] = 23
            array[3] = 00	<-- the string is shorter than the array

            Return Values:
            0		SUCESS
            1		non valid character
        */

    int i;

    // init with zeros
    for (i = 0; i < array_size; i++)
    {
        array[i] = 0;
    }
    for (i = 0; i < array_size; i++)
    {
        // convert the first 4 bit of the byte
        if ( ( (i*2)>=string_size ) || ( string.at(2*i) == '\0' ) )
        {
            return 0; // end of data
        }

        if ( ( string.at(2*i) >= 0x30 ) && ( string.at(2*i) <= 0x39 ) )
        {
            // if it is a "normal" number
            array[i] = ( string.at(2*i)-0x30 ) << 4;
        }
        else if ( ( string.at(2*i) >= 0x41 ) && ( string.at(2*i) <= 0x46 ) )
        {
            // if it is a number from A to F
            array[i] = ( string.at(2*i) - 0x41 + 10 ) << 4;
        }
        else if ( ( string.at(2*i) >= 0x61 ) && ( string.at(2*i) <= 0x66 ) )
        {
            // if it is a number from a to f
            array[i] = ( string.at(2*i) - 0x61 + 10 ) << 4;
        }
        else
        {
            return 1;	// non valid character
        }

        // convert the second 4 bit of the byte
        if ( ( ((i*2)+1) >= string_size ) || ( string.at((2*i)+1) == '\0') )
        {
            break;
        }

        if ( ( string.at((2*i)+1) >= 0x30 ) && ( string.at((2*i)+1) <= 0x39 ) )
        {
            // if it is a "normal" number
            array[i] += string.at((2*i)+1)-0x30;
        }
        else if ( ( string.at((2*i)+1) >= 0x41 ) && ( string.at((2*i)+1) <= 0x46 ) )
        {
            // if it is a number from A to F
            array[i] += string.at((2*i)+1) - 0x41 + 10;
        }
        else if ( ( string.at((2*i)+1) >= 0x61 ) && ( string.at((2*i)+1) <= 0x66 ) )
        {
            // if it is a number from a to f
            array[i] += string.at((2*i)+1) - 0x61 + 10;
        }
        else
        {
            return 1; // non valid character
        }
    }
    return 0;
}

int	CharArrayToHexString (wchar_t* string, unsigned char* array, int array_size)
{

    /*
        Converts a char array (like generated by the function above) to a string.
        The string has to be at least 2*array_size long.
        Will always return 0
    */
    for (int i=0; i < array_size; i++)
    {
        int rightint = array[i] % 16;
        int leftint = array[i] - rightint;
        leftint = leftint >> 4;

        // convert left part
        if ( leftint < 10 )
        {
            string[ 2 * i ] = leftint + 0x30;
        }
        else
        {
            string[ 2 * i ] = leftint + 0x40 - 9;
        }

        // convert right part
        if ( rightint < 10 )
        {
            string[ ( 2 * i ) + 1 ] = rightint + 0x30;
        }
        else
        {
            string[ ( 2 * i ) + 1 ] = rightint + 0x40 - 9;
        }
    }
    return 0; // sucess
}

int	CharArrayToHexString (std::string &string, unsigned char* array, int array_size)
{
    /*
        Converts a char array (like generated by the function above) to a string.
        The string has to be at least 2*array_size long.
        Will always return 0
    */
    for (int i=0; i < array_size; i++)
    {
        int rightint = array[i] % 16;
        int leftint = array[i] - rightint;
        leftint = leftint >> 4;

        // convert left part
        if ( leftint < 10 )
        {
            string.at(2*i) = leftint + 0x30;
        }
        else
        {
            string.at(2*i) = leftint + 0x40 - 9;
        }

        // convert right part
        if ( rightint < 10 )
        {
            string.at(2*i + 1) = rightint + 0x30;
        }
        else
        {
            string.at(2*i + 1) = rightint + 0x40 - 9;
        }
    }
    return 0; // sucess
}

int UnsignedIntToSignedInt (int UnsignedInt, int MSB)
{
    /*
            This function excepts a int (like it is generated during the interpreting)
            that has data in it that should be an signed int (but the msb of the data
            is not the msb of the int) and then it converts it to an real int. The return
            value will always be the result (the signed int)

            for example:
            UnsignedInt = 0x00...FF
            MSB=1 (bits are numbered from right to left)
            Return Value = -1 (0xFF....FF)
        */

    // check if the data is negative
    if ( !( UnsignedInt & (0x1 << MSB) ) )
    {
        // nothing to do here
        return UnsignedInt;
    }

    int SignedInt = UnsignedInt; // copy data so we can work with it

    // fill up the data in front of the MSB with ones
    for (int i = MSB+1; i < (int)sizeof(int)*8; i++)
    {
        SignedInt |= ( 0x1 << i );
    }

    return SignedInt;

}
int CutOffDataFromInt (int original, int MSB)
{
    /*
            This function replaces everything left of the MSB with 0 and returns
            the result.
            The first bit is 0 and the bits are numbered from right to left.

            example:
            original=0x...FF MSB=3
            Return Value: 0x00...0F
        */
    int cutedInt=original; // copy the original value to modify it

    for (int i = MSB+1; i < (int)sizeof(int)*8; i++)
    {
        // this loop will take care of every bit in front of the MSB seperatly
        // It first creates a mask that is made up by all zeros except for the position
        // of the bit that should be removed. This mask is then inverted so that it is
        // all zeros except for the position that should be removed. Then we use an and
        // operation with cutedInt and the mask to remove the masked bit.
        cutedInt &= ~( 0x1 << i );
    }

    return cutedInt;
}
int DecodeDataToString (unsigned char* array, wchar_t* ID, wchar_t* CONFIG, wchar_t* START, wchar_t* CRC, wchar_t* DATA)
{
    /*
        Decodes an CanOverEthernet message into null terminated strings.
        Size of Strings
        ID:		7
        CONFIG:	3
        START:	3
        CRC:	3
        DATA:	17

        This function will always return 0
    */

    // convert the data to a null terminated string
    wchar_t tmp_string[29];
    CharArrayToHexString(tmp_string, array, 14);

    // and then cut it into pieces

    int i;

    for (i = 0; i < 2; i++)
    {
        START [i] = tmp_string [i];
    }

    START [2] = '\0';

    for (i = 0; i < 2; i++)
    {
        CONFIG [i] = tmp_string [2+i];
    }

    CONFIG [2] = '\0';
    for (int j=0; j < 3; j++)
    {
        // ID needs special treatment because it is converted from little to
        // big endian
        for (i = 0; i < 2; i++)
        {
            ID [2*j+i] = tmp_string [4+2*(2-j)+i];
        }
    }
    ID [6] = '\0';

    for (i = 0; i < 16; i++)
    {
        DATA [i] = tmp_string [10+i];
    }

    DATA [16] = '\0';

    for (i = 0; i < 2; i++)
    {
        CRC [i] = tmp_string [26+i];
    }

    CRC [2] = '\0';

    return 0;
}
int SendCanMessage (int ID, char* Data)
{
    struct RawData tmp; // the message

    // check if ID is correct
    if ( (ID < 0) || (ID > 0xFFFFFF) )
    {
        return 1;
    }

    // set Start and Config Field
    tmp.RawData[0] = 0xAA;	// start
    tmp.RawData[1] = 0x00; // config

    // set ID
    tmp.RawData[2] = ID & 0xFF;
    tmp.RawData[3] = (ID >> 8) & 0xFF;
    tmp.RawData[4] = (ID >> 16) & 0xFF;

    // set Message
    for (int i=0; i < 8; i++)
    {
        tmp.RawData[5 + i] = Data[i];
    }

    // calculate CRC
    int crc = 0;	// the checksum
    for (int i = 1; i <= 12; i++)
    {
        crc += tmp.RawData[i];
        // add the value of all data, id and config bytes
    }
    crc &= 0xFF; // drop everything but the last byte
    crc ^= 0xFF; // Invert (XOR with 0xFF)

    // write the checksum to the message
    tmp.RawData [13] = crc;

    // send the message
    NetLock->lock();
    SendData.push(tmp);
    NetLock->unlock();
    return 0;

}

int ggT(int a, int b){
//returns the greatest common divisor
    if(b == 0)

        return a;

    else return ggT(b, a % b);

}
}
