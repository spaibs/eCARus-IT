<?xml version="1.0" encoding="UTF-8"?>
<pl n="gtfmetainfo" xmlns:p="GUIDE plugin">
<a n="version">5.5</a>
<a n="versionPatch">3</a>
<p:F>
<p:f n="language">
<a n="funD">Switches the language of all global properties that are not in a special group.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="languageId">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The ID of the language to switch to.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="language_of_group">
<a n="funD">Switches the language of only a group of global properties.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="groupId">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The ID of the group of global properties for which to switch the language.</a>
<a n="pDV"/>
</p:p>
<p:p n="languageId">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The ID of the language to switch to.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="variant">
<a n="funD">Switches the variant of all global properties that are not in a special group.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="variantId">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The ID of the variant to switch to.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="variant_of_group">
<a n="funD">Switches the variant of only a group of global properties.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="groupId">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The ID of the group of global properties for which to switch the variant.</a>
<a n="pDV"/>
</p:p>
<p:p n="variantId">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The ID of the variant to switch to.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="assign_language_labels">
<a n="funD">Fills a global property string list with the labels of all known languages.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="dstItemId">
<a n="pT">30</a>
<a n="pC"/>
<a n="pD">The ID of a global property in which to store the language labels. The global property must be a string list.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="assign_variant_labels">
<a n="funD">Fills a global property string list with the labels of all known variants.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="dstItemId">
<a n="pT">30</a>
<a n="pC"/>
<a n="pD">The ID of a global property in which to store the variant labels. The global property must be a string list.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="assign_language_ids">
<a n="funD">Fills a global property integer list with the IDs of all known languages.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="dstItemId">
<a n="pT">30</a>
<a n="pC"/>
<a n="pD">The ID of a global property in which to store the language IDs. The global property must be a list of unsigned integers.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="assign_variant_ids">
<a n="funD">Fills a global property integer list with the IDs of all known variants.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="dstItemId">
<a n="pT">30</a>
<a n="pC"/>
<a n="pD">The ID of a global property in which to store the variant IDs. The global property must be a list of unsigned integers.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="trace_string">
<a n="funD">Writes a string to the trace log and the connection log.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="str">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The text to trace.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="trace_dp">
<a n="funD">Writes debugging information about a datapool item to the trace log and the connection log.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="itemId">
<a n="pT">30</a>
<a n="pC"/>
<a n="pD">Datapool Id of the item to trace debug info about.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="request_runlevel">
<a n="funD">Requests the framework to switch to a different runlevel. The only supported runlevel is 0, meaning to shutdown the program.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="runlevel">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The requested runlevel.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="make_persistent">
<a n="funD">Save all persistent datapool entries, languages and variants.</a>
<a n="funRT">42</a>
<p:funP/>
</p:f>
<p:f n="uint2string">
<a n="funD">Simple integer to string conversion for unsigned integers.</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="value">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">The value to convert to string.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="int2string">
<a n="funD">Simple integer to string conversion for signed integers.</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="value">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The value to convert to string.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="float2string">
<a n="funD">Simple float to string conversion.</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="value">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">The value to convert to string.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="string2string">
<a n="funD">string formatting for strings</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="str">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">the string to format</a>
<a n="pDV"/>
</p:p>
<p:p n="len">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">maximum length of the string</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="formatInteger">
<a n="funD">Advanced integer to string conversion.</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="minStrLen">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Minimum length of the result string.</a>
<a n="pDV"/>
</p:p>
<p:p n="maxStrLen">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Maximum length of the result string.</a>
<a n="pDV"/>
</p:p>
<p:p n="showAbsoluteValue">
<a n="pT">0</a>
<a n="pC"/>
<a n="pD">If value is negative, the formatter negates it before formatting (thus turning it positive).</a>
<a n="pDV"/>
</p:p>
<p:p n="alwaysShowSign">
<a n="pT">0</a>
<a n="pC"/>
<a n="pD">Forces the formatter to show the sign for both negative and positive values.</a>
<a n="pDV"/>
</p:p>
<p:p n="fillStyle">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The character to use to ensure the minimum length of the result string. 0: fills with blanks, 1: fills with zeros.</a>
<a n="pDV"/>
</p:p>
<p:p n="base">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">2: binary, 10: decimal; 16: hexadecimal</a>
<a n="pDV"/>
</p:p>
<p:p n="value">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The number to format.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="formatFloat">
<a n="funD">Advanced float to string conversion.</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="minStrLen">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Minimum length of the result string.</a>
<a n="pDV"/>
</p:p>
<p:p n="maxStrLen">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Maximum length of the result string.</a>
<a n="pDV"/>
</p:p>
<p:p n="minPrecision">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Minimum number of decimal places.</a>
<a n="pDV"/>
</p:p>
<p:p n="maxPrecision">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Maximum number of decimal places.</a>
<a n="pDV"/>
</p:p>
<p:p n="showAbsoluteValue">
<a n="pT">0</a>
<a n="pC"/>
<a n="pD">If value is negative, the formatter negates it before formatting (thus turning it positive).</a>
<a n="pDV"/>
</p:p>
<p:p n="alwaysShowSign">
<a n="pT">0</a>
<a n="pC"/>
<a n="pD">Forces the formatter to show the sign for both negative and positive values.</a>
<a n="pDV"/>
</p:p>
<p:p n="roundingMode">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The rounding mode, the formatter uses to ensure the maximum length of the result string. 0: trunc, 1: round</a>
<a n="pDV"/>
</p:p>
<p:p n="fillStyle">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The character to use to ensure the minimum length of the result string. 0: fills with blanks, 1: fills with zeros.</a>
<a n="pDV"/>
</p:p>
<p:p n="value">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">The number to format.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="localtime_second">
<a n="funD">Extracts the seconds in local time from a system time value.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="time">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">A time stamp as returned by system_time.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="localtime_minute">
<a n="funD">Extracts the minutes in local time from a system time value.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="time">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">A time stamp as returned by system_time.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="localtime_hour">
<a n="funD">Extracts the hours in local time from a system time value.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="time">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">A time stamp as returned by system_time.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="localtime_day">
<a n="funD">Extracts the day [1:31] in local time from a system time value.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="time">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">A time stamp as returned by system_time.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="localtime_weekday">
<a n="funD">Extracts the week day [0:6] in local time from a system time value. 0 is Sunday.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="time">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">A time stamp as returned by system_time.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="localtime_month">
<a n="funD">Extracts the month [0:11] in local time from a system time value.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="time">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">A time stamp as returned by system_time.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="localtime_year">
<a n="funD">Extracts the year in local time from a system time value.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="time">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">A time stamp as returned by system_time.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="system_time">
<a n="funD">Gets the current system time in seconds. The result is intended to be passed to the localtime_* functions.</a>
<a n="funRT">3</a>
<p:funP/>
</p:f>
<p:f n="system_time_ms">
<a n="funD">Gets the current system time in milliseconds.</a>
<a n="funRT">3</a>
<p:funP/>
</p:f>
<p:f n="rand">
<a n="funD">Gets a random value between 0 and 0xFFFFFFFF.</a>
<a n="funRT">7</a>
<p:funP/>
</p:f>
<p:f n="seed_rand">
<a n="funD">Sets the seed of the random number generator.</a>
<a n="funRT">42</a>
<p:funP>
<p:p n="seed">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The value to seed the random number generator.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="hsba2color">
<a n="funD">Converts from HSB/HSV color space to GTF color.</a>
<a n="funRT">28</a>
<p:funP>
<p:p n="hue">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The color value in degrees from 0 to 360.</a>
<a n="pDV"/>
</p:p>
<p:p n="saturation">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The saturation in percent.</a>
<a n="pDV"/>
</p:p>
<p:p n="brightness">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The brightness in percent.</a>
<a n="pDV"/>
</p:p>
<p:p n="alpha">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The alpha value. 0 means totally transparent, 255 means opaque.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="rgba2color">
<a n="funD">Converts from RGB color space to GTF color.</a>
<a n="funRT">28</a>
<p:funP>
<p:p n="red">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The red color coordinate in range 0 to 255</a>
<a n="pDV"/>
</p:p>
<p:p n="green">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The green color coordinate in range 0 to 255</a>
<a n="pDV"/>
</p:p>
<p:p n="blue">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The blue color coordinate in range 0 to 255</a>
<a n="pDV"/>
</p:p>
<p:p n="alpha">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The alpha value. 0 means totally transparent, 255 means opaque.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="round">
<a n="funD">Rounds to nearest integer, but round halfway cases away from zero.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="value">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">The value to round.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="trunc">
<a n="funD">Rounds to nearest integer, always towards zero.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="value">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">The value to round.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="floor">
<a n="funD">Returns the largest integral value not greater than the argument.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="value">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">The value to round.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="ceil">
<a n="funD">Returns the smallest integral value not less than the argument.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="value">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">The value to round.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="nearbyint">
<a n="funD">Rounds to nearest integer.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="value">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">The value to round.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="int2float">
<a n="funD">Returns the integer, as floating point value.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="value">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The value to convert to float.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="uint2float">
<a n="funD">Returns the integer, as floating point value.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="value">
<a n="pT">3</a>
<a n="pC"/>
<a n="pD">The value to convert to float.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="string2int">
<a n="funD">Converts the initial portion of the string to int. The result is clipped to 2147483647 and -2147483648 if the input is greater or smaller than these values. If the string does not start with a number, the function returns 0.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="str">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The string value</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="character2unicode">
<a n="funD">Returns the Unicode value of a characterThe Unicode value of the first character found in the string is returned.In case of errors 0 is returned.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="str">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The string value</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="string2float">
<a n="funD">Converts the initial portion of the string to float.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="str">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The string value</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="sinf">
<a n="funD">Returns the sine of x, where x is given in radians.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="cosf">
<a n="funD">Returns the cosine of x, where x is given in radians.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="tanf">
<a n="funD">Returns the tangent of x, where x is given in radians.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="asinf">
<a n="funD">Calculates the principal value of the arc sine of x; that is the value whose sine is x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="acosf">
<a n="funD">Calculates the principal value of the arc cosine of x; that is the value whose cosine is x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="atanf">
<a n="funD">Calculates the principal value of the arc tangent of x; that is the value whose tangent is x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="color2string">
<a n="funD">prints a color as 8 hexadecimal values</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="value">
<a n="pT">28</a>
<a n="pC"/>
<a n="pD">The color to convert to string.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="expf">
<a n="funD">Returns the value of e (the base of natural logarithms) raised to the power of x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="logf">
<a n="funD">Returns the natural logarithm of x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="log10f">
<a n="funD">Returns the base 10 logarithm of x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="sqrtf">
<a n="funD">Returns the nonnegative square root of x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="powf">
<a n="funD">Returns the value of x raised to the power of y.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument x.</a>
<a n="pDV"/>
</p:p>
<p:p n="y">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument y.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="atan2f">
<a n="funD">Calculates the principal value of the arc tangent of y/x, using the signs of the two arguments to determine the quadrant of the result.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="y">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument y.</a>
<a n="pDV"/>
</p:p>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument x.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="atan2i">
<a n="funD">Calculates the principal value of the arc tangent of y/x, using the signs of the two arguments to determine the quadrant of the result.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="y">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Argument y.</a>
<a n="pDV"/>
</p:p>
<p:p n="x">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Argument x.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="absf">
<a n="funD">Returns the absolute value of the floating-point number x.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="abs">
<a n="funD">Returns the absolute value of the integer number x.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="x">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Parameter.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="deg2rad">
<a n="funD">Converts an angle form degree to radians.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="rad2deg">
<a n="funD">Converts an angle form radians to degree.</a>
<a n="funRT">9</a>
<p:funP>
<p:p n="x">
<a n="pT">9</a>
<a n="pC"/>
<a n="pD">Argument.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="substring">
<a n="funD">Creates a substring copy of the given string. Negative end indexes are supported. For example: substring(&quot;abc&quot;, 0, -1) takes the whole string; substring(&quot;abc&quot;, 0, -2) drops the last character.</a>
<a n="funRT">11</a>
<p:funP>
<p:p n="str">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The input string.</a>
<a n="pDV"/>
</p:p>
<p:p n="startIndex">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The index of the first character of the result string</a>
<a n="pDV"/>
</p:p>
<p:p n="endIndex">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The index of the first character that is not part of the result</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="getTextWidth">
<a n="funD">Obtain the width of a text regarding its font resource.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="text">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The text which shall be evaluated.</a>
<a n="pDV"/>
</p:p>
<p:p n="font">
<a n="pT">37</a>
<a n="pC"/>
<a n="pD">The font which shall be used to evaluate the text size.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="getTextHeight">
<a n="funD">Obtain the height of a text regarding its font resource.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="text">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The text which shall be evaluated.</a>
<a n="pDV"/>
</p:p>
<p:p n="font">
<a n="pT">37</a>
<a n="pC"/>
<a n="pD">The font which shall be used to evaluate the text size.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="getTextLength">
<a n="funD">Obtain the number of characters of a text.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="text">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The text which shall be evaluated.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="transformToWidgetX">
<a n="funD">Obtain the x-coordinate in widget-local coordinate system from the supplied screen coordinates.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="widget">
<a n="pT">51</a>
<a n="pC"/>
<a n="pD">The widget of which to obtain relative coordinate position.</a>
<a n="pDV"/>
</p:p>
<p:p n="worldCoordinateX">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The world coordinate position in x-direction to transform to local one.</a>
<a n="pDV"/>
</p:p>
<p:p n="worldCoordinateY">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The world coordinate position in y-direction to transform to local one.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="transformToWidgetY">
<a n="funD">Obtain the y-coordinate in widget-local coordinate system from the supplied screen coordinates.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="widget">
<a n="pT">51</a>
<a n="pC"/>
<a n="pD">The widget of which to obtain relative coordinate position.</a>
<a n="pDV"/>
</p:p>
<p:p n="worldCoordinateX">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The world coordinate position in x-direction to transform to local one.</a>
<a n="pDV"/>
</p:p>
<p:p n="worldCoordinateY">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The world coordinate position in y-direction to transform to local one.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="transformToScreenX">
<a n="funD">Obtain the x-coordinate in screen coordinate system from the supplied local coordinates of a widget.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="widget">
<a n="pT">51</a>
<a n="pC"/>
<a n="pD">The widget of which to obtain screen coordinate position.</a>
<a n="pDV"/>
</p:p>
<p:p n="localCoordinateX">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The local coordinate position in x-direction to transform to screen-relative one.</a>
<a n="pDV"/>
</p:p>
<p:p n="localCoordinateY">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The local coordinate position in y-direction to transform to screen-relative one.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="transformToScreenY">
<a n="funD">Obtain the y-coordinate in screen coordinate system from the supplied local coordinates of a widget.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="widget">
<a n="pT">51</a>
<a n="pC"/>
<a n="pD">The widget of which to obtain screen coordinate position.</a>
<a n="pDV"/>
</p:p>
<p:p n="localCoordinateX">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The local coordinate position in x-direction to transform to screen-relative one.</a>
<a n="pDV"/>
</p:p>
<p:p n="localCoordinateY">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">The local coordinate position in y-direction to transform to screen-relative one.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="has_list_window">
<a n="funD">Returns true if the given index within a global list property is valid and located inside at least one window. Otherwise returns false.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="itemId">
<a n="pT">30</a>
<a n="pC"/>
<a n="pD">Datapool ID of the global list property.</a>
<a n="pDV"/>
</p:p>
<p:p n="index">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">Index within the global list property.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_play">
<a n="funD">Starts or continues an animation, unless the animation is already running.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_reverse">
<a n="funD">Plays an animation backwards</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_running">
<a n="funD">Determines whether an animation is currently running.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_pause">
<a n="funD">Pauses an animation.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_set_time">
<a n="funD">Sets the current time of an animation, can be used to skip or replay an animation.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
<p:p n="time">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">time</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_cancel">
<a n="funD">Cancels an animation, leaving manipulated properties in the current state.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_cancel_reset">
<a n="funD">Cancels an animation and resets manipulated properties to the init state, as far as possible.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_cancel_end">
<a n="funD">Cancels an animation and sets manipulated properties to the end state, as far as possible.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_beyond">
<a n="funD">Checks if an animation running forward has already passed a given point in time.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
<p:p n="time">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">time</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="animation_before">
<a n="funD">Checks if an animation running backwards has already passed a given point in time.</a>
<a n="funRT">0</a>
<p:funP>
<p:p n="animation">
<a n="pT">46</a>
<a n="pC"/>
<a n="pD">The animation to manipulate.</a>
<a n="pDV"/>
</p:p>
<p:p n="time">
<a n="pT">7</a>
<a n="pC"/>
<a n="pD">time</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="widgetGetChildCount">
<a n="funD">Obtain the number of child widgets of the given widget.</a>
<a n="funRT">7</a>
<p:funP>
<p:p n="widget">
<a n="pT">51</a>
<a n="pC"/>
<a n="pD">The widget of which to obtain the number of children.</a>
<a n="pDV"/>
</p:p>
</p:funP>
</p:f>
<p:f n="focusNext">
<a n="funD">Forces the focus manager to forward the focus to the next focusable element.</a>
<a n="funRT">42</a>
<p:funP/>
</p:f>
<p:f n="focusPrevious">
<a n="funD">Forces the focus manager to backward the focus to the previous focusable element.</a>
<a n="funRT">42</a>
<p:funP/>
</p:f>
</p:F>
<p:PT>
<p:ptI n="GtfTypeRecord">
<a n="id">46</a>
</p:ptI>
<p:ptI n="bool">
<a n="id">0</a>
</p:ptI>
<p:ptI n="bytearray">
<a n="id">49</a>
</p:ptI>
<p:ptI n="color">
<a n="id">28</a>
</p:ptI>
<p:ptI n="data">
<a n="id">12</a>
</p:ptI>
<p:ptI n="double">
<a n="id">10</a>
</p:ptI>
<p:ptI n="dp_id">
<a n="id">30</a>
</p:ptI>
<p:ptI n="dp_list_element_const">
<a n="id">44</a>
</p:ptI>
<p:ptI n="dp_list_element_item">
<a n="id">45</a>
</p:ptI>
<p:ptI n="event">
<a n="id">52</a>
</p:ptI>
<p:ptI n="event_id">
<a n="id">35</a>
</p:ptI>
<p:ptI n="float">
<a n="id">9</a>
</p:ptI>
<p:ptI n="font">
<a n="id">37</a>
</p:ptI>
<p:ptI n="function|bool|int32_t">
<a n="id">132</a>
</p:ptI>
<p:ptI n="function|bool|int32_t|int32_t">
<a n="id">128</a>
</p:ptI>
<p:ptI n="function|bool|int32_t|int32_t|int32_t|int32_t">
<a n="id">134</a>
</p:ptI>
<p:ptI n="function|bool|int32_t|int32_t|int32_t|int32_t|int32_t">
<a n="id">135</a>
</p:ptI>
<p:ptI n="function|bool|string">
<a n="id">133</a>
</p:ptI>
<p:ptI n="function|color|int32_t|int32_t">
<a n="id">130</a>
</p:ptI>
<p:ptI n="function|float|int32_t|int32_t">
<a n="id">129</a>
</p:ptI>
<p:ptI n="function|int32_t|int32_t|int32_t">
<a n="id">131</a>
</p:ptI>
<p:ptI n="function|void|bool|int32_t">
<a n="id">137</a>
</p:ptI>
<p:ptI n="function|void|float|int32_t|int32_t">
<a n="id">136</a>
</p:ptI>
<p:ptI n="function|void|int32_t">
<a n="id">126</a>
</p:ptI>
<p:ptI n="function|void|int32_t|bool">
<a n="id">125</a>
</p:ptI>
<p:ptI n="function|void|int32_t|bool|int32_t">
<a n="id">138</a>
</p:ptI>
<p:ptI n="function|void|int32_t|int32_t">
<a n="id">127</a>
</p:ptI>
<p:ptI n="function|void|void">
<a n="id">123</a>
</p:ptI>
<p:ptI n="image">
<a n="id">39</a>
</p:ptI>
<p:ptI n="int16_t">
<a n="id">6</a>
</p:ptI>
<p:ptI n="int32_t">
<a n="id">7</a>
</p:ptI>
<p:ptI n="int64_t">
<a n="id">8</a>
</p:ptI>
<p:ptI n="int8_t">
<a n="id">5</a>
</p:ptI>
<p:ptI n="invalid">
<a n="id">41</a>
</p:ptI>
<p:ptI n="list bool">
<a n="id">14</a>
</p:ptI>
<p:ptI n="list color">
<a n="id">29</a>
</p:ptI>
<p:ptI n="list data">
<a n="id">27</a>
</p:ptI>
<p:ptI n="list double">
<a n="id">25</a>
</p:ptI>
<p:ptI n="list float">
<a n="id">24</a>
</p:ptI>
<p:ptI n="list font">
<a n="id">38</a>
</p:ptI>
<p:ptI n="list image">
<a n="id">40</a>
</p:ptI>
<p:ptI n="list int16_t">
<a n="id">21</a>
</p:ptI>
<p:ptI n="list int32_t">
<a n="id">22</a>
</p:ptI>
<p:ptI n="list int64_t">
<a n="id">23</a>
</p:ptI>
<p:ptI n="list int8_t">
<a n="id">20</a>
</p:ptI>
<p:ptI n="list model">
<a n="id">48</a>
</p:ptI>
<p:ptI n="list srgs_grammar">
<a n="id">56</a>
</p:ptI>
<p:ptI n="list string">
<a n="id">26</a>
</p:ptI>
<p:ptI n="list uint16_t">
<a n="id">16</a>
</p:ptI>
<p:ptI n="list uint32_t">
<a n="id">17</a>
</p:ptI>
<p:ptI n="list uint64_t">
<a n="id">18</a>
</p:ptI>
<p:ptI n="list uint8_t">
<a n="id">15</a>
</p:ptI>
<p:ptI n="list uintptr_t">
<a n="id">19</a>
</p:ptI>
<p:ptI n="list void">
<a n="id">43</a>
</p:ptI>
<p:ptI n="model">
<a n="id">47</a>
</p:ptI>
<p:ptI n="popupstack_id">
<a n="id">33</a>
</p:ptI>
<p:ptI n="propertyContainer">
<a n="id">50</a>
</p:ptI>
<p:ptI n="speech_hmi_slot">
<a n="id">57</a>
</p:ptI>
<p:ptI n="speech_static_slot">
<a n="id">58</a>
</p:ptI>
<p:ptI n="srgs_grammar">
<a n="id">55</a>
</p:ptI>
<p:ptI n="state_id">
<a n="id">36</a>
</p:ptI>
<p:ptI n="statemachine_id">
<a n="id">32</a>
</p:ptI>
<p:ptI n="string">
<a n="id">11</a>
</p:ptI>
<p:ptI n="template_id">
<a n="id">34</a>
</p:ptI>
<p:ptI n="uint16_t">
<a n="id">2</a>
</p:ptI>
<p:ptI n="uint32_t">
<a n="id">3</a>
</p:ptI>
<p:ptI n="uint64_t">
<a n="id">4</a>
</p:ptI>
<p:ptI n="uint8_t">
<a n="id">1</a>
</p:ptI>
<p:ptI n="uintptr_t">
<a n="id">13</a>
</p:ptI>
<p:ptI n="view_id">
<a n="id">31</a>
</p:ptI>
<p:ptI n="virtualfont">
<a n="id">246</a>
</p:ptI>
<p:ptI n="void">
<a n="id">42</a>
</p:ptI>
<p:ptI n="widget">
<a n="id">51</a>
</p:ptI>
</p:PT>
<p:W>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfAbstractWidget">
<a n="wC"/>
<a n="wA">GtfAbstractWidget</a>
<a n="wS"/>
<a n="wT">GtfAbstractWidget</a>
<a n="wCHC">false</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="name">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The name of the widget. The naming may be restricted by the project options. &lt;br&gt;Two widgets with the same direct parent may not have the same name</a>
<a n="pDV"/>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfAbstractVisualWidget">
<a n="wC"/>
<a n="wA">Abstract Visual Widget</a>
<a n="wS">GtfAbstractWidget</a>
<a n="wT">GtfAbstractVisualWidget</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="height">
<a n="pT">7</a>
<a n="pC">Layout</a>
<a n="pD">The height of the widget, in some cases this is also used for clipping. Refer to the renderer manual for more details</a>
<a n="pDV">50</a>
</p:p>
<p:p n="visible">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Determines wether the widget is visible. Note that even if the visible property is set to true, a widget may be invisible if it is a child of an invisible parent widget.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="width">
<a n="pT">7</a>
<a n="pC">Layout</a>
<a n="pD">The width of the widget, in some cases the width is also used for clipping. Refer to the renderer manual for more details</a>
<a n="pDV">50</a>
</p:p>
<p:p n="x">
<a n="pT">7</a>
<a n="pC">Layout</a>
<a n="pD">The x coordinate of the widget</a>
<a n="pDV">0</a>
</p:p>
<p:p n="y">
<a n="pT">7</a>
<a n="pC">Layout</a>
<a n="pD">The y coordinate of the widget</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfLabel">
<a n="wC">Basic Widget Set</a>
<a n="wA">Label</a>
<a n="wS">GtfAbstractVisualWidget</a>
<a n="wT">GtfLabel</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="text">
<a n="pT">11</a>
<a n="pC">Appearance</a>
<a n="pD">The displayed text string of the label.</a>
<a n="pDV">label</a>
</p:p>
<p:p n="textColor">
<a n="pT">28</a>
<a n="pC">Appearance</a>
<a n="pD">The colour which is used to display &quot;text&quot;.</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="font">
<a n="pT">37</a>
<a n="pC">Appearance</a>
<a n="pD">Determines which font is used for rendering.</a>
<a n="pDV"/>
</p:p>
<p:p n="horizontalAlign">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The x alignment of the text inside the bounding box of the widget.</a>
<a n="pDV">0</a>
<p:PC>
<a n="center">1</a>
<a n="trailing">2</a>
<a n="leading">0</a>
</p:PC>
</p:p>
<p:p n="verticalAlign">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The y alignment of the text inside the bounding box of the widget.</a>
<a n="pDV">0</a>
<p:PC>
<a n="center">0</a>
<a n="bottom">2</a>
<a n="top">1</a>
</p:PC>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfImage">
<a n="wC">Basic Widget Set</a>
<a n="wA">Image</a>
<a n="wS">GtfAbstractVisualWidget</a>
<a n="wT">GtfImage</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="image">
<a n="pT">39</a>
<a n="pC">Appearance</a>
<a n="pD">The filename of the image.</a>
<a n="pDV"/>
</p:p>
<p:p n="horizontalAlign">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The x alignment of the image inside the bounding box of the widget.</a>
<a n="pDV">0</a>
<p:PC>
<a n="center">1</a>
<a n="trailing">2</a>
<a n="leading">0</a>
</p:PC>
</p:p>
<p:p n="verticalAlign">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The y alignment of the image inside the bounding box of the widget.</a>
<a n="pDV">1</a>
<p:PC>
<a n="center">0</a>
<a n="bottom">2</a>
<a n="top">1</a>
</p:PC>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfApplicationWindowWidget">
<a n="wC">Basic Widget Set</a>
<a n="wA">Application Window</a>
<a n="wS">GtfImage</a>
<a n="wT">GtfApplicationWindowWidget</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">true</a>
<p:WP>
<p:p n="forwardTouch">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Determines whether the widget should forward touch to a corresponding application.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="forwardKey">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Determines whether the widget should forward key and rotary input to a corresponding application.</a>
<a n="pDV">true</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfRectangle">
<a n="wC">Basic Widget Set</a>
<a n="wA">Rectangle</a>
<a n="wS">GtfAbstractVisualWidget</a>
<a n="wT">GtfRectangle</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="fillColor">
<a n="pT">28</a>
<a n="pC">Appearance</a>
<a n="pD">The color which will be used to fill the rectangle</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfInstantiator">
<a n="wC">Basic Widget Set</a>
<a n="wA">Instantiator</a>
<a n="wS">GtfAbstractVisualWidget</a>
<a n="wT">GtfInstantiator</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">true</a>
<p:WP>
<p:p n="numItems">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The number of instantiated child elements (list length).</a>
<a n="pDV">0</a>
</p:p>
<p:p n="lineMapping">
<a n="pT">22</a>
<a n="pC">Appearance</a>
<a n="pD">Defines which children should be used as template for which line. If no list is defined the first template is used for all elements. &lt;br&gt;If a list is defined the list length will limit the number of instantiated children.</a>
<a n="pDV"/>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfContainer">
<a n="wC">Basic Widget Set</a>
<a n="wA">Container</a>
<a n="wS">GtfAbstractVisualWidget</a>
<a n="wT">GtfContainer</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP/>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfView">
<a n="wC">Basic Widget Set</a>
<a n="wA">View</a>
<a n="wS">GtfAbstractVisualWidget</a>
<a n="wT">GtfView</a>
<a n="wCHC">true</a>
<a n="wIV">true</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP/>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfAbstractLogicWidget">
<a n="wC"/>
<a n="wA">Abstract Logic Widget</a>
<a n="wS">GtfAbstractWidget</a>
<a n="wT">GtfAbstractLogicWidget</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP/>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfAbstractAnimation">
<a n="wC">Animation</a>
<a n="wA">Abstract Animation</a>
<a n="wS">GtfAbstractLogicWidget</a>
<a n="wT">GtfAbstractAnimation</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="enabled">
<a n="pT">0</a>
<a n="pC">common</a>
<a n="pD">defines whether the animation may be executed</a>
<a n="pDV">true</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfAnimationContainer">
<a n="wC">Animation</a>
<a n="wA">Animation Container</a>
<a n="wS">GtfAbstractAnimation</a>
<a n="wT">GtfAnimationContainer</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="repeat">
<a n="pT">7</a>
<a n="pC">Loop and time control</a>
<a n="pD">Repeat is the number of cycles the animation runs.&lt;br&gt;If this property is set to zero the animation runs infinitely.</a>
<a n="pDV">1</a>
</p:p>
<p:p n="alternating">
<a n="pT">0</a>
<a n="pC">Loop and time control</a>
<a n="pD">The flag &quot;alternating&quot; defines whether or not the animation should be alternate repeatedly. This happens only if the animation cycles more than once.</a>
<a n="pDV">false</a>
</p:p>
<p:p n="scale">
<a n="pT">9</a>
<a n="pC">Loop and time control</a>
<a n="pD">The temporal &quot;scale&quot; multiplies the animation timing by the scale value.</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="onPlay">
<a n="pT">125</a>
<a n="pC">Callbacks</a>
<a n="pD">The reaction &quot;onPlay&quot; is executed when the animation is started or continued.&lt;br&gt;The parameters are:&lt;BLOCKQUOTE&gt;&lt;strong&gt;animation_time&lt;/strong&gt;&lt;br&gt;This is the start time for the animation. &lt;br&gt;&lt;br&gt;&lt;strong&gt;forward&lt;/strong&gt;&lt;br&gt;This is the play direction. If it is true the animation goes forward and if it is false the animation goes backward.&lt;/BLOCKQUOTE&gt;</a>
<a n="pDV">function(v:animation_time::int32_t, v:forward::bool){}</a>
</p:p>
<p:p n="onPause">
<a n="pT">126</a>
<a n="pC">Callbacks</a>
<a n="pD">The reaction &quot;onPause&quot; is executed when the animation is paused.&lt;br&gt;&lt;br&gt;&lt;BLOCKQUOTE&gt;&lt;strong&gt;animation_time&lt;/strong&gt;&lt;br&gt;This is the time at which the animation is set to pause.&lt;/BLOCKQUOTE&gt;</a>
<a n="pDV">function(v:animation_time::int32_t ){}</a>
</p:p>
<p:p n="onTerminate">
<a n="pT">127</a>
<a n="pC">Callbacks</a>
<a n="pD">The reaction &quot;onTerminate&quot; is executed when the animation terminates.&lt;br&gt;The parameters are:&lt;BLOCKQUOTE&gt;&lt;strong&gt;animation_time&lt;/strong&gt;&lt;br&gt;This is the length of time for which the animation was running.&lt;br&gt;&lt;br&gt;&lt;strong&gt;terminate&lt;/strong&gt;&lt;br&gt;This parameter specifies the reason for the termination:&lt;br&gt;&lt;BLOCKQUOTE&gt;0: normal termination due to animation completion&lt;/BLOCKQUOTE&gt;&lt;br&gt;&lt;BLOCKQUOTE&gt;1: cancel triggered by the action f:animation_cancel&lt;/BLOCKQUOTE&gt;&lt;br&gt;&lt;BLOCKQUOTE&gt;2: widget is destroyed due to view transition&lt;/BLOCKQUOTE&gt;&lt;br&gt;&lt;BLOCKQUOTE&gt;3: jump to end, final step of animation is executed then the animation is canceled, caused by f:animation_cancel_end&lt;/BLOCKQUOTE&gt;&lt;br&gt;&lt;BLOCKQUOTE&gt;4: reset and cancel, the first step of the animation is executed and then canceled, caused by f:animation_cancel_reset&lt;/BLOCKQUOTE&gt;&lt;/BLOCKQUOTE&gt;</a>
<a n="pDV">function(v:animation_time::int32_t, v:terminate::int32_t){}</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfParallelAnimation">
<a n="wC">Animation</a>
<a n="wA">Animation</a>
<a n="wS">GtfAnimationContainer</a>
<a n="wT">GtfParallelAnimation</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP/>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfDelayedFixedCurve">
<a n="wC">Animation</a>
<a n="wA">Fixed Delayed Curve</a>
<a n="wS">GtfAbstractAnimation</a>
<a n="wT">GtfDelayedFixedCurve</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="delay">
<a n="pT">7</a>
<a n="pC">Loop and time control</a>
<a n="pD">delay in ms relative to the beginning of the animation</a>
<a n="pDV">0</a>
</p:p>
<p:p n="duration">
<a n="pT">7</a>
<a n="pC">Loop and time control</a>
<a n="pD">duration of this curve segment in milliseconds</a>
<a n="pDV">1000</a>
</p:p>
<p:p n="repeat">
<a n="pT">7</a>
<a n="pC">Loop and time control</a>
<a n="pD">number of repeats, set to zero for infinite number of repeats</a>
<a n="pDV">1</a>
</p:p>
<p:p n="alternating">
<a n="pT">0</a>
<a n="pC">Loop and time control</a>
<a n="pD">define whether the curve should be repeated alternating</a>
<a n="pDV">false</a>
</p:p>
<p:p n="relative">
<a n="pT">0</a>
<a n="pC">Curve Settings</a>
<a n="pD">define whether the update values are applied upon the initial value</a>
<a n="pDV">false</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfConstCurveS32">
<a n="wC">Animation</a>
<a n="wA">Constant Curve Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfConstCurveS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="value">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value</a>
<a n="pDV">0</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfConstCurveColor">
<a n="wC">Animation</a>
<a n="wA">Constant Curve Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfConstCurveColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="value">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfConstCurveBool">
<a n="wC">Animation</a>
<a n="wA">Constant Curve Bool</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfConstCurveBool</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="value">
<a n="pT">0</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value</a>
<a n="pDV">false</a>
</p:p>
<p:p n="target">
<a n="pT">0</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">false</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfConstCurveFloat">
<a n="wC">Animation</a>
<a n="wA">Constant Curve Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfConstCurveFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="value">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfLinearInterpolationS32">
<a n="wC">Animation</a>
<a n="wA">Linear Interpolation Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfLinearInterpolationS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0</a>
</p:p>
<p:p n="end">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">1</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfLinearInterpolationColor">
<a n="wC">Animation</a>
<a n="wA">Linear Interpolation Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfLinearInterpolationColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="end">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">255,255,255,255</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfLinearInterpolationFloat">
<a n="wC">Animation</a>
<a n="wA">Linear Interpolation Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfLinearInterpolationFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="end">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfSlowStartS32">
<a n="wC">Animation</a>
<a n="wA">Slow Start Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfSlowStartS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0</a>
</p:p>
<p:p n="end">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">1</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfSlowStartColor">
<a n="wC">Animation</a>
<a n="wA">Slow Start Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfSlowStartColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="end">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">255,255,255,255</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfSlowStartFloat">
<a n="wC">Animation</a>
<a n="wA">Slow Start Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfSlowStartFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="end">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfFastStartS32">
<a n="wC">Animation</a>
<a n="wA">Fast Start Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfFastStartS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0</a>
</p:p>
<p:p n="end">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">1</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfFastStartColor">
<a n="wC">Animation</a>
<a n="wA">Fast Start Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfFastStartColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="end">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">255,255,255,255</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfFastStartFloat">
<a n="wC">Animation</a>
<a n="wA">Fast Start Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfFastStartFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="start">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">initial value</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="end">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">destination value</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfQuadraticCurveS32">
<a n="wC">Animation</a>
<a n="wA">Quadratic Curve Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfQuadraticCurveS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="acceleration">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">acceleration of the curve</a>
<a n="pDV">1</a>
</p:p>
<p:p n="velocity">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">velocity of the curve</a>
<a n="pDV">0</a>
</p:p>
<p:p n="constant">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value of the curve</a>
<a n="pDV">0</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfQuadraticCurveColor">
<a n="wC">Animation</a>
<a n="wA">Quadratic Curve Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfQuadraticCurveColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="acceleration">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">acceleration of the curve</a>
<a n="pDV">10,10,10,10</a>
</p:p>
<p:p n="velocity">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">velocity of the curve</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="constant">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value of the curve</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfQuadraticCurveFloat">
<a n="wC">Animation</a>
<a n="wA">Quadratic Curve Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfQuadraticCurveFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="acceleration">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">acceleration of the curve</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="velocity">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">velocity of the curve</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="constant">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value of the curve</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfSinusCurveS32">
<a n="wC">Animation</a>
<a n="wA">Sinus Curve Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfSinusCurveS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="amplitude">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">amplitude value</a>
<a n="pDV">100</a>
</p:p>
<p:p n="constant">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value</a>
<a n="pDV">0</a>
</p:p>
<p:p n="frequency">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">frequency in hertz</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="phase">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">angular phase translation in degrees</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfSinusCurveColor">
<a n="wC">Animation</a>
<a n="wA">Sinus Curve Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfSinusCurveColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="amplitude">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">amplitude value</a>
<a n="pDV">255,255,255,255</a>
</p:p>
<p:p n="constant">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="frequency">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">frequency in hertz</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="phase">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">angular phase translation in degrees</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfSinusCurveFloat">
<a n="wC">Animation</a>
<a n="wA">Sinus Curve Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfSinusCurveFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="amplitude">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">amplitude value</a>
<a n="pDV">100.0</a>
</p:p>
<p:p n="constant">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant value</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="frequency">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">frequency in hertz</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="phase">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">angular phase translation in degrees</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfLinearCurveS32">
<a n="wC">Animation</a>
<a n="wA">Linear Curve Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfLinearCurveS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="velocity">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">velocity</a>
<a n="pDV">1</a>
</p:p>
<p:p n="constant">
<a n="pT">7</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant</a>
<a n="pDV">0</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfLinearCurveColor">
<a n="wC">Animation</a>
<a n="wA">Linear Curve Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfLinearCurveColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="velocity">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">velocity</a>
<a n="pDV">10,10,10,10</a>
</p:p>
<p:p n="constant">
<a n="pT">28</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant</a>
<a n="pDV">0,0,0,255</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfLinearCurveFloat">
<a n="wC">Animation</a>
<a n="wA">Linear Curve Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfLinearCurveFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="velocity">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">velocity</a>
<a n="pDV">1.0</a>
</p:p>
<p:p n="constant">
<a n="pT">9</a>
<a n="pC">Curve Settings</a>
<a n="pD">constant</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfScriptCurveBool">
<a n="wC">Animation</a>
<a n="wA">Script Curve Bool</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfScriptCurveBool</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="curve">
<a n="pT">128</a>
<a n="pC">Curve Settings</a>
<a n="pD">curve function, that takes a diff and animtion time in ms</a>
<a n="pDV">function(v:diff::int32_t, v:t_anim::int32_t) { false }</a>
</p:p>
<p:p n="target">
<a n="pT">0</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">false</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfScriptCurveS32">
<a n="wC">Animation</a>
<a n="wA">Script Curve Integer</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfScriptCurveS32</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="curve">
<a n="pT">131</a>
<a n="pC">Curve Settings</a>
<a n="pD">curve function, that takes a diff and animtion time in ms</a>
<a n="pDV">function(v:diff::int32_t, v:t_anim::int32_t) { 0::int32_t }</a>
</p:p>
<p:p n="target">
<a n="pT">7</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfScriptCurveColor">
<a n="wC">Animation</a>
<a n="wA">Script Curve Color</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfScriptCurveColor</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="curve">
<a n="pT">130</a>
<a n="pC">Curve Settings</a>
<a n="pD">curve function, that takes a diff and animtion time in ms</a>
<a n="pDV">function(v:diff::int32_t, v:t_anim::int32_t) { color: 0,0,0,255 }</a>
</p:p>
<p:p n="target">
<a n="pT">28</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0,0,0,255</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfScriptCurveFloat">
<a n="wC">Animation</a>
<a n="wA">Script Curve Float</a>
<a n="wS">GtfDelayedFixedCurve</a>
<a n="wT">GtfScriptCurveFloat</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP>
<p:p n="curve">
<a n="pT">129</a>
<a n="pC">Curve Settings</a>
<a n="pD">curve function, that takes a diff and animtion time in ms</a>
<a n="pDV">function(v:diff::int32_t, v:t_anim::int32_t) { 0.0 }</a>
</p:p>
<p:p n="target">
<a n="pT">9</a>
<a n="pC">Target</a>
<a n="pD">target property to assign the resulting value</a>
<a n="pDV">0.0</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfCustomEffect">
<a n="wC">Common</a>
<a n="wA">Custom Effect</a>
<a n="wS"/>
<a n="wT">GtfCustomEffect</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="name">
<a n="pT">11</a>
<a n="pC"/>
<a n="pD">The name of the Effect.</a>
<a n="pDV"/>
</p:p>
<p:p n="enabled">
<a n="pT">0</a>
<a n="pC">common</a>
<a n="pD">This flag defines if the Effect is enabled or not.</a>
<a n="pDV">true</a>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfViewManager">
<a n="wC">Common</a>
<a n="wA">View Manager</a>
<a n="wS">GtfContainer</a>
<a n="wT">GtfViewManager</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP/>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfVisualScene">
<a n="wC">Common</a>
<a n="wA">Scene</a>
<a n="wS">GtfContainer</a>
<a n="wT">GtfVisualScene</a>
<a n="wCHC">true</a>
<a n="wIV">true</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="projectName">
<a n="pT">11</a>
<a n="pC">common</a>
<a n="pD">project name</a>
<a n="pDV">project</a>
</p:p>
<p:p n="sceneId">
<a n="pT">7</a>
<a n="pC">common</a>
<a n="pD">unique identifier for the scene</a>
<a n="pDV">0</a>
</p:p>
<p:p n="offscreenBuffer">
<a n="pT">39</a>
<a n="pC">common</a>
<a n="pD">result buffer of the scene rendering, only used when offscreenDisplay is enabled</a>
<a n="pDV"/>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfSpeechScene">
<a n="wC">Common</a>
<a n="wA">SpeechScene</a>
<a n="wS">GtfAbstractWidget</a>
<a n="wT">GtfSpeechScene</a>
<a n="wCHC">true</a>
<a n="wIV">true</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP>
<p:p n="onInitialized">
<a n="pT">137</a>
<a n="pC">common</a>
<a n="pD">Speech dialog has been initialized</a>
<a n="pDV">function( v:success::bool, v:errorCode::int32_t ) { }</a>
</p:p>
<p:p n="onDeinitialized">
<a n="pT">137</a>
<a n="pC">common</a>
<a n="pD">Speech dialog has been deinitialized</a>
<a n="pDV">function( v:success::bool, v:errorCode::int32_t ) { }</a>
</p:p>
<p:p n="onLanguageChangeStarted">
<a n="pT">126</a>
<a n="pC">common</a>
<a n="pD">Language change has been started</a>
<a n="pDV">function( v:languageCode::int32_t ) { }</a>
</p:p>
<p:p n="onLanguageChanged">
<a n="pT">138</a>
<a n="pC">common</a>
<a n="pD">Language has been changed</a>
<a n="pDV">function( v:languageCode::int32_t, v:success::bool, v:errorCode::int32_t ) { }</a>
</p:p>
<p:p n="onOutputStarted">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Speech output has started</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="onOutputFinished">
<a n="pT">137</a>
<a n="pC">common</a>
<a n="pD">Speech output has finished</a>
<a n="pDV">function( v:success::bool, v:errorCode::int32_t ) { }</a>
</p:p>
<p:p n="onRecStarted">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Recognition has started</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="onRecInfoSignalTooWeak">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Recognition information: Signal too weak</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="onRecInfoSignalTooLoud">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Recognition information: Signal too loud</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="onRecInfoSnrTooLow">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Recognition information: Signal-noise-ratio too low</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="onRecInfoSpokeTooEarly">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Recognition information: Speaker spoke too early</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="onRecFinished">
<a n="pT">137</a>
<a n="pC">common</a>
<a n="pD">Recognition has finished</a>
<a n="pDV">function( v:success::bool, v:errorCode::int32_t ) { }</a>
</p:p>
<p:p n="onRecTimeout">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Recognition timeout occurred</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="onRecEmptyResult">
<a n="pT">123</a>
<a n="pC">common</a>
<a n="pD">Recognition contains no valid results</a>
<a n="pDV">function( ) { }</a>
</p:p>
<p:p n="recNBestResultList">
<a n="pT">26</a>
<a n="pC">common</a>
<a n="pD">Contains recognized commands (n-best list) for disambiguation.</a>
<a n="pDV"/>
</p:p>
</p:WP>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfTalkManager">
<a n="wC">Common</a>
<a n="wA">Talk Manager</a>
<a n="wS">GtfAbstractWidget</a>
<a n="wT">GtfTalkManager</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">true</a>
<a n="wII">false</a>
<p:WP/>
</p:w>
<p:w n="com.elektrobit.guide.plugins.gtf.adapter.widgetfactory.GtfWidgetFactory|createWidget|GtfExtensionPoint">
<a n="wC">$inv$Extension$Point</a>
<a n="wA">$inv$Extension$Point</a>
<a n="wS">GtfAbstractWidget</a>
<a n="wT">GtfExtensionPoint</a>
<a n="wCHC">true</a>
<a n="wIV">false</a>
<a n="wIA">false</a>
<a n="wII">false</a>
<p:WP/>
</p:w>
</p:W>
<p:WF>
<p:wf n="VirtualLayer">
<a n="fc">Common</a>
<a n="fd">Defines that a widget is bound to a certain layer. This layer is virtual and will be mapped during runtime to a real hardware layer.</a>
<a n="frc">w:GtfCustomEffect||w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="layerId">
<a n="pT">7</a>
<a n="pC">Layout</a>
<a n="pD">The identifier for the virtual layer the widget or effect currently belongs to.</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="TextTruncation">
<a n="fc">Common</a>
<a n="fd">This feature shows an indication if &quot;text&quot; does not fit into the designated widget area</a>
<a n="frc">w:GtfLabel</a>
<p:fP>
<p:p n="truncationSymbol">
<a n="pT">11</a>
<a n="pC">Appearance</a>
<a n="pD">The string which should be used for text truncation.</a>
<a n="pDV">...</a>
</p:p>
<p:p n="truncationPolicy">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">Determines the place where the truncation occurs, eg. at the beginning, center or end of &quot;text&quot;.</a>
<a n="pDV">2</a>
<p:PC>
<a n="trailing">2</a>
<a n="leading">0</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="MultiLine">
<a n="fc">Common</a>
<a n="fd">This feature enables support for multi line texts.</a>
<a n="frc">w:GtfLabel</a>
<p:fP>
<p:p n="lineGap">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">Gap between two lines of text.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="currentLineCount">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">Current number of lines.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="maxLineCount">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">Maximum number of visible lines. Values lesser or equal 0 mean infinite number of visible lines.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="lineSeparators">
<a n="pT">26</a>
<a n="pC">Appearance</a>
<a n="pD">Line separator chars.</a>
<a n="pDV"/>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Border">
<a n="fc">Effect</a>
<a n="fd">Defines how borders shall be drawn</a>
<a n="frc">w:GtfRectangle||w:GtfLabel||w:GtfImage</a>
<p:fP>
<p:p n="borderThickness">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The thickness of the rectangle border - in pixels</a>
<a n="pDV">1</a>
</p:p>
<p:p n="borderColor">
<a n="pT">28</a>
<a n="pC">Appearance</a>
<a n="pD">The color which will be used to render the border</a>
<a n="pDV">255,255,255,255</a>
</p:p>
<p:p n="borderStyle">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The style which is used to render the border.</a>
<a n="pDV">0</a>
<p:PC>
<a n="solid">0</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="ScaleMode">
<a n="fc">Layout</a>
<a n="fd">Defines the scale mode of the image.</a>
<a n="frc">w:GtfImage</a>
<p:fP>
<p:p n="scaleMode">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The scale mode of the image.</a>
<a n="pDV">0</a>
<p:PC>
<a n="keep aspect ratio">2</a>
<a n="fit to Size">1</a>
<a n="original Size">0</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="MoveOver">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon a move within its boundaries</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="moveOver">
<a n="pT">134</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction when moving over the widget</a>
<a n="pDV">function(v:touchId::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="MoveOut">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon a move out of its boundaries</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="moveOut">
<a n="pT">134</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction when moving out of the bounding box of the widget</a>
<a n="pDV">function(v:touchId::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="MoveIn">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon a move into its boundaries</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="moveIn">
<a n="pT">134</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction when moving into the bounding box of the widget</a>
<a n="pDV">function(v:touchId::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="TouchPressed">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon a press</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="touchPressed">
<a n="pT">134</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on touch pressed</a>
<a n="pDV">function(v:touchId::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="TouchShortReleased">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon a release</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="touchShortReleased">
<a n="pT">134</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the release of the touch screen</a>
<a n="pDV">function(v:touchId::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="TouchGrabLost">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon a grab lost situation</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="onTouchGrabLost">
<a n="pT">134</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on widget losing touch grab</a>
<a n="pDV">function(v:touchId::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="TouchStatusChanged">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon status changes</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="touchStatusChanged">
<a n="pT">135</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on a touch status change</a>
<a n="pDV">function(v:touchId::int32_t, v:touchStatus::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="TouchMove">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget reacts upon touch movements</a>
<a n="frc">wf:StateTouched</a>
<p:fP>
<p:p n="touchMoved">
<a n="pT">134</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on touch move</a>
<a n="pDV">function(v:touchId::int32_t, v:x::int32_t, v:y::int32_t, v:fingerId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Gestures">
<a n="fc">Input handling</a>
<a n="fd">Defines that the respective widget is interested in processing touch gestures</a>
<a n="frc">wf:StateTouched</a>
<p:fP/>
</p:wf>
<p:wf n="GestureHold">
<a n="fc">Gestures</a>
<a n="fd">Defines that the respective widget reacts upon hold gesture</a>
<a n="frc">wf:Gestures</a>
<p:fP>
<p:p n="onGestureHold">
<a n="pT">127</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the hold gesture</a>
<a n="pDV">function(v:x::int32_t, v:y::int32_t) {}</a>
</p:p>
<p:p n="holdDuration">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the duration of the contact for the hold gesture to be recognized</a>
<a n="pDV">1000</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="GestureLongHold">
<a n="fc">Gestures</a>
<a n="fd">Defines that the respective widget reacts upon long hold gesture</a>
<a n="frc">wf:Gestures</a>
<p:fP>
<p:p n="onGestureLongHold">
<a n="pT">127</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the long hold gesture</a>
<a n="pDV">function(v:x::int32_t, v:y::int32_t) {}</a>
</p:p>
<p:p n="longHoldDuration">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the duration of the contact for the long hold gesture to be recognized</a>
<a n="pDV">3000</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="GestureFlick">
<a n="fc">Gestures</a>
<a n="fd">Defines that the respective widget reacts upon flick gesture</a>
<a n="frc">wf:Gestures</a>
<p:fP>
<p:p n="onGestureFlick">
<a n="pT">136</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the flick gesture</a>
<a n="pDV">function(v:speed::float, v:directionX::int32_t, v:directionY::int32_t) {}</a>
</p:p>
<p:p n="flickMaxTime">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the maximal time (in milliseconds) a flick gesture can take to be recognized</a>
<a n="pDV">400</a>
</p:p>
<p:p n="flickMinLength">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the minimal length (in pixels) a flick gesture must cover to be recognizer</a>
<a n="pDV">100</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="GesturePinch">
<a n="fc">Gestures</a>
<a n="fd">Defines that the respective widget reacts upon pinch gesture</a>
<a n="frc">wf:Gestures</a>
<p:fP>
<p:p n="onGesturePinchStart">
<a n="pT">136</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the start of pinch gesture</a>
<a n="pDV">function(v:ratio::float, v:centerX::int32_t, v:centerY::int32_t) {}</a>
</p:p>
<p:p n="onGesturePinchUpdate">
<a n="pT">136</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the update of pinch gesture</a>
<a n="pDV">function(v:ratio::float, v:centerX::int32_t, v:centerY::int32_t) {}</a>
</p:p>
<p:p n="onGesturePinchEnd">
<a n="pT">136</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the end of pinch gesture</a>
<a n="pDV">function(v:ratio::float, v:centerX::int32_t, v:centerY::int32_t) {}</a>
</p:p>
<p:p n="pinchThreshold">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the threshold for the pinch gesture to start</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="GestureRotate">
<a n="fc">Gestures</a>
<a n="fd">Defines that the respective widget reacts upon rotate gesture</a>
<a n="frc">wf:Gestures</a>
<p:fP>
<p:p n="onGestureRotateStart">
<a n="pT">136</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the start of rotate gesture</a>
<a n="pDV">function(v:angle::float, v:centerX::int32_t, v:centerY::int32_t) {}</a>
</p:p>
<p:p n="onGestureRotateUpdate">
<a n="pT">136</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the update of rotate gesture</a>
<a n="pDV">function(v:angle::float, v:centerX::int32_t, v:centerY::int32_t) {}</a>
</p:p>
<p:p n="onGestureRotateEnd">
<a n="pT">136</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the end of rotate gesture</a>
<a n="pDV">function(v:angle::float, v:centerX::int32_t, v:centerY::int32_t) {}</a>
</p:p>
<p:p n="rotateThreshold">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the threshold for the rotate gesture to start</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Path">
<a n="fc">Gestures</a>
<a n="fd">Defines that the respective widget reacts upon path gestures</a>
<a n="frc">wf:Gestures</a>
<p:fP>
<p:p n="onPath">
<a n="pT">126</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on a recognized path</a>
<a n="pDV">function(v:gestureId::int32_t) {}</a>
</p:p>
<p:p n="onPathStart">
<a n="pT">123</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction on the possible start of a path gesture</a>
<a n="pDV">function() {}</a>
</p:p>
<p:p n="onPathNotRecognized">
<a n="pT">123</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the reaction when a path gesture is not recognized</a>
<a n="pDV">function() {}</a>
</p:p>
<p:p n="pathMinXBox">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the minimal x movement for a path gesture recognizer to start handling the input</a>
<a n="pDV">50</a>
</p:p>
<p:p n="pathMinYBox">
<a n="pT">3</a>
<a n="pC">Touch event</a>
<a n="pD">Defines the minimal y movement for a path gesture recognizer to start handling the input</a>
<a n="pDV">50</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="ToggleButton">
<a n="fc">Common</a>
<a n="fd">This feature changes a button into a Togglebutton. In contrast to the Pushbutton the &quot;pressed&quot; state will be kept if the button has been released.</a>
<a n="frc">wf:StateTouched||wf:StatePressed</a>
<p:fP/>
</p:wf>
<p:wf n="KeyPressed">
<a n="fc">Input handling</a>
<a n="fd">Defines that the widgets reacts upon the press of a key</a>
<a n="frc">wf:StatePressed</a>
<p:fP>
<p:p n="keyPressed">
<a n="pT">132</a>
<a n="pC">Key event</a>
<a n="pD">Defines the reaction on a press event</a>
<a n="pDV">function(v:keyId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="KeyUnicode">
<a n="fc">Input handling</a>
<a n="fd">Defines that the widgets reacts upon a unicode key input</a>
<a n="frc">wf:StatePressed</a>
<p:fP>
<p:p n="keyUnicode">
<a n="pT">133</a>
<a n="pC">Key event</a>
<a n="pD">Defines the reaction on a key unicode event</a>
<a n="pDV">function(v:key::string) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="KeyShortReleased">
<a n="fc">Input handling</a>
<a n="fd">Defines that the widgets reacts upon the release of a key</a>
<a n="frc">wf:StatePressed</a>
<p:fP>
<p:p n="keyShortReleased">
<a n="pT">132</a>
<a n="pC">Key event</a>
<a n="pD">Defines the reaction on a release event</a>
<a n="pDV">function(v:keyId::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="KeyStatusChanged">
<a n="fc">Input handling</a>
<a n="fd">Defines that the widgets reacts upon the status change of a key</a>
<a n="frc">wf:StatePressed</a>
<p:fP>
<p:p n="keyStatusChanged">
<a n="pT">128</a>
<a n="pC">Key event</a>
<a n="pD">Defines the reaction on a key status change</a>
<a n="pDV">function(v:keyId::int32_t, v:status::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Rotary">
<a n="fc">Input handling</a>
<a n="fd">Defines that the widgets reacts upon rotary events</a>
<a n="frc">wf:StateFocused</a>
<p:fP>
<p:p n="rotaryReaction">
<a n="pT">128</a>
<a n="pC">Key event</a>
<a n="pD">Defines the reaction rotary pressed</a>
<a n="pDV">function(v:rotaryId::int32_t, v:increment::int32_t) { false }</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="StateEnabled">
<a n="fc">Common</a>
<a n="fd">This feature adds the state &quot;enabled&quot; to the widget</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="enabled">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Defines whether the widget is currently enabled</a>
<a n="pDV">true</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="StateSelected">
<a n="fc">Common</a>
<a n="fd">This feature adds the states &quot;selected&quot; to the widget.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="selected">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Defines whether the widget is currently selected</a>
<a n="pDV">true</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="StateFocused">
<a n="fc">Common</a>
<a n="fd">Defines that the widgets may have an input focus</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="focusable">
<a n="pT">7</a>
<a n="pC">Behavior</a>
<a n="pD">Defines whether the widget is currently focusable.</a>
<a n="pDV">3</a>
<p:PC>
<a n="focusable">3</a>
<a n="not focusable">0</a>
<a n="only by key">2</a>
<a n="only by touch">1</a>
</p:PC>
</p:p>
<p:p n="focused">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Defines whether the widget is currently focused</a>
<a n="pDV">false</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="StatePressed">
<a n="fc">Common</a>
<a n="fd">Defines that the widgets may have a pressed state</a>
<a n="frc">wf:StateFocused</a>
<p:fP>
<p:p n="pressed">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Defines whether the widget is currently pressed</a>
<a n="pDV">false</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="StateTouched">
<a n="fc">Common</a>
<a n="fd">Defines that the widgets may have touch support</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="touchable">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Indicates whether the widget is able to react on touch events.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="touched">
<a n="pT">0</a>
<a n="pC">Behavior</a>
<a n="pD">Defines whether the widget just received a touch event (temporary state).</a>
<a n="pDV">false</a>
</p:p>
<p:p n="touchPolicy">
<a n="pT">7</a>
<a n="pC">Behavior</a>
<a n="pD">Defines how to handle touch and move that cross widget boundaries.&lt;br&gt;Three policies are available:&lt;BLOCKQUOTE&gt;&lt;strong&gt;Press then react&lt;/strong&gt;&lt;br&gt;Press first then the widget reacts.&lt;br&gt;Move notifications and release are only active within the widget boundaries.&lt;/BLOCKQUOTE&gt; &lt;BLOCKQUOTE&gt;&lt;strong&gt;Press and grab&lt;/strong&gt;&lt;br&gt;Press to grab the information.&lt;br&gt;The information remains grabbed even if the cursor moves away from the widget.&lt;/BLOCKQUOTE&gt; &lt;BLOCKQUOTE&gt;&lt;strong&gt;Press then react on contact&lt;/strong&gt;&lt;br&gt;The widget can be pressed from outside it's boundaries but the press only&lt;br&gt;becomes active when the cursor moves into the widgets boundaries.&lt;br&gt;Move notifications and release are only active within the widget boundaries.&lt;br&gt;Press and grab is excepted here.&lt;/BLOCKQUOTE&gt;</a>
<a n="pDV">0</a>
<p:PC>
<a n="Press then react">0</a>
<a n="Press then react on contact">2</a>
<a n="Press and grab">1</a>
</p:PC>
</p:p>
<p:p n="touchBehavior">
<a n="pT">7</a>
<a n="pC">Behavior</a>
<a n="pD">Defines if a widget being touched is figured out by evaluating the widget the touched pixel belongs to or against the widget's clipping rectangle.</a>
<a n="pDV">0</a>
<p:PC>
<a n="Visible pixels">1</a>
<a n="Whole area">0</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="UserDefinedFocus">
<a n="fc">Focus</a>
<a n="fd">This feature enables focus capabilities for the widget. &lt;br&gt;The widget manages a local focus hierarchy for its widget tree. &lt;br&gt;The focus order itself can be controlled by the focusOrder variable for the children.</a>
<a n="frc">w:GtfAbstractVisualWidget&amp;&amp;!wf:AutoFocus&amp;&amp;wf:StateFocused</a>
<p:fP>
<p:p n="initFocus">
<a n="pT">7</a>
<a n="pC">Focus Policy</a>
<a n="pD">Defines the initial focus for the focus handling. The initFocus defines the n-th child widget which should be focused. If this widget is not focusable the next focusable child will be used.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="focusedIndex">
<a n="pT">7</a>
<a n="pC">Focus Policy</a>
<a n="pD">Defines the current focused child widget as the n-th child widget which is focusable</a>
<a n="pDV">0</a>
</p:p>
<p:p n="focusNext">
<a n="pT">0</a>
<a n="pC">Focus Policy</a>
<a n="pD">The condition on which the focus index shall be incremented.</a>
<a n="pDV">false</a>
</p:p>
<p:p n="focusPrev">
<a n="pT">0</a>
<a n="pC">Focus Policy</a>
<a n="pD">The condition on which the focus index shall be decremented.</a>
<a n="pDV">false</a>
</p:p>
<p:p n="focusFlow">
<a n="pT">7</a>
<a n="pC">Focus Policy</a>
<a n="pD">Defines the behavior for the focus flow.&lt;BLOCKQUOTE&gt;&lt;strong&gt;stop at hierarchy level&lt;/strong&gt;&lt;br&gt;Means that the focus will stop at the first or last focusable child in the hierarchy level.&lt;/BLOCKQUOTE&gt;&lt;BLOCKQUOTE&gt;&lt;strong&gt;wrap within hierarchy level&lt;/strong&gt;&lt;br&gt;Means that the focus will wrap at the first and last focusable child in the hierarchy level.&lt;/BLOCKQUOTE&gt;&lt;BLOCKQUOTE&gt;&lt;strong&gt;step up in hierarchy&lt;/strong&gt;&lt;br&gt;Means that the focus will change from the last focusable child to the parent hierarchy's next child and from the first child &lt;br&gt;to the parent hierarchy's previous child.&lt;br&gt;This means we step out of the focus hierarchy level to the one above.&lt;/BLOCKQUOTE&gt;</a>
<a n="pDV">0</a>
<p:PC>
<a n="step up in hierarchy">2</a>
<a n="wrap within hierarchy level">1</a>
<a n="stop at hierarchy level">0</a>
</p:PC>
</p:p>
<p:p n="focusOrder">
<a n="pT">22</a>
<a n="pC">Focus Policy</a>
<a n="pD">Defines the focus order for its child widgets depending on the order of the children in the widget tree.&lt;br&gt; If no focusOrder has been defined, the widget order will be used instead.&lt;br&gt; Each of the child widgets requires an active &quot;Focus state&quot; feature, otherwise those widgets are ignored for focus handling.&lt;br&gt;&lt;br&gt; Example: &lt;BLOCKQUOTE&gt;focusOrder=2|1|3&lt;/BLOCKQUOTE&gt;&lt;br&gt;means: &lt;BLOCKQUOTE&gt;the second widget receives the focus first, afterwards the first widget and finally the third widget.&lt;/BLOCKQUOTE&gt;</a>
<a n="pDV"/>
</p:p>
</p:fP>
</p:wf>
<p:wf n="AutoFocus">
<a n="fc">Focus</a>
<a n="fd">This feature enables focus capabilities for the widget. &lt;br&gt;The widget manages a local focus hierarchy for its widget tree. &lt;br&gt;The order of the widgets in the layout will be used to calculate the focus order. &lt;br&gt;Depending on the layout orientation the algorithm begins in the upper left or upper right corner.</a>
<a n="frc">w:GtfAbstractVisualWidget&amp;&amp;!wf:UserDefinedFocus&amp;&amp;wf:StateFocused</a>
<p:fP>
<p:p n="initFocus">
<a n="pT">7</a>
<a n="pC">Focus Policy</a>
<a n="pD">Defines the initial focus for the focus handling. The initFocus defines the n-th child widget which should be focused.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="focusedIndex">
<a n="pT">7</a>
<a n="pC">Focus Policy</a>
<a n="pD">Defines the current focused child widget as the n-th child widget which is focusable</a>
<a n="pDV">0</a>
</p:p>
<p:p n="focusNext">
<a n="pT">0</a>
<a n="pC">Focus Policy</a>
<a n="pD">The condition on which the focus index shall be incremented.</a>
<a n="pDV">false</a>
</p:p>
<p:p n="focusPrev">
<a n="pT">0</a>
<a n="pC">Focus Policy</a>
<a n="pD">The condition on which the focus index shall be decremented.</a>
<a n="pDV">false</a>
</p:p>
<p:p n="focusFlow">
<a n="pT">7</a>
<a n="pC">Focus Policy</a>
<a n="pD">Defines the behavior for the focus flow.&lt;BLOCKQUOTE&gt;&lt;strong&gt;stop at hierarchy level&lt;/strong&gt;&lt;br&gt;Means that the focus will stop at the first or last focusable child in the hierarchy level.&lt;/BLOCKQUOTE&gt;&lt;BLOCKQUOTE&gt;&lt;strong&gt;wrap within hierarchy level&lt;/strong&gt;&lt;br&gt;Means that the focus will wrap at the first and last focusable child in the hierarchy level.&lt;/BLOCKQUOTE&gt;&lt;BLOCKQUOTE&gt;&lt;strong&gt;step up in hierarchy&lt;/strong&gt;&lt;br&gt;Means that the focus will change from the last focusable child to the parent hierarchy's next child and from the first child &lt;br&gt;to the parent hierarchy's previous child.&lt;br&gt;This means we step out of the focus hierarchy level to the one above.&lt;/BLOCKQUOTE&gt;</a>
<a n="pDV">0</a>
<p:PC>
<a n="step up in hierarchy">2</a>
<a n="wrap within hierarchy level">1</a>
<a n="stop at hierarchy level">0</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LayoutPolicyAbsolute">
<a n="fc">Layout</a>
<a n="fd">Adds the layout policy &quot;absolute layout&quot; mechanism to a widget</a>
<a n="frc">w:GtfAbstractVisualWidget&amp;&amp;!wf:LayoutPolicyFlow&amp;&amp;!wf:LayoutPolicyGrid&amp;&amp;!wf:LayoutPolicyBox&amp;&amp;!wf:LayoutPolicyList</a>
<p:fP>
<p:p n="itemLeftOffset">
<a n="pT">22</a>
<a n="pC">Layout policy</a>
<a n="pD">Integer list, storing the offset from the left border for all children.</a>
<a n="pDV"/>
</p:p>
<p:p n="itemTopOffset">
<a n="pT">22</a>
<a n="pC">Layout policy</a>
<a n="pD">Integer list, storing the offset from the top border for all children.</a>
<a n="pDV"/>
</p:p>
<p:p n="itemRightOffset">
<a n="pT">22</a>
<a n="pC">Layout policy</a>
<a n="pD">Integer list, storing the offset from the right border for all children.</a>
<a n="pDV"/>
</p:p>
<p:p n="itemBottomOffset">
<a n="pT">22</a>
<a n="pC">Layout policy</a>
<a n="pD">Integer list, storing the offset from the bottom border for all children.</a>
<a n="pDV"/>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LayoutPolicyFlow">
<a n="fc">Layout</a>
<a n="fd">Adds the layout policy &quot;flow layout&quot; mechanism to a widget</a>
<a n="frc">w:GtfAbstractVisualWidget&amp;&amp;!wf:LayoutPolicyAbsolute&amp;&amp;!wf:LayoutPolicyGrid&amp;&amp;!wf:LayoutPolicyBox&amp;&amp;!wf:LayoutPolicyList</a>
<p:fP>
<p:p n="horizontalGap">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The horizontal space between two children.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="verticalGap">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The vertical space between two children.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="layoutDirection">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Defines the direction in which the child widgets should be aligned.</a>
<a n="pDV">0</a>
<p:PC>
<a n="vertical">1</a>
<a n="horizontal">0</a>
</p:PC>
</p:p>
<p:p n="horizontalChildAlign">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Defines the alignment for the children within the component.</a>
<a n="pDV">0</a>
<p:PC>
<a n="center">1</a>
<a n="trailing">2</a>
<a n="leading">0</a>
</p:PC>
</p:p>
<p:p n="verticalChildAlign">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Defines the alignment for the children within the component.</a>
<a n="pDV">0</a>
<p:PC>
<a n="center">0</a>
<a n="bottom">2</a>
<a n="top">1</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LayoutPolicyGrid">
<a n="fc">Layout</a>
<a n="fd">Adds the layout policy &quot;grid layout&quot; mechanism to a widget</a>
<a n="frc">w:GtfAbstractVisualWidget&amp;&amp;!wf:LayoutPolicyAbsolute&amp;&amp;!wf:LayoutPolicyFlow&amp;&amp;!wf:LayoutPolicyBox&amp;&amp;!wf:LayoutPolicyList</a>
<p:fP>
<p:p n="horizontalGap">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The horizontal space between two children.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="verticalGap">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The vertical space between two children.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="numRows">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Defines the number of rows. If set to &quot;-1&quot; the amount of children defines the number of rows.</a>
<a n="pDV">-1</a>
</p:p>
<p:p n="numColumns">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Defines the number of columns. If set to &quot;-1&quot; the amount of children defines the number of columns.</a>
<a n="pDV">-1</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LayoutPolicyBox">
<a n="fc">Layout</a>
<a n="fd">Adds the layout policy &quot;box layout&quot; mechanism to a widget</a>
<a n="frc">w:GtfAbstractVisualWidget&amp;&amp;!wf:LayoutPolicyAbsolute&amp;&amp;!wf:LayoutPolicyFlow&amp;&amp;!wf:LayoutPolicyGrid&amp;&amp;!wf:LayoutPolicyList</a>
<p:fP>
<p:p n="gap">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The space between two children. The gap will be evaluated according to the layout direction (e.g. horizontal direction means horizontal gap).</a>
<a n="pDV">0</a>
</p:p>
<p:p n="layoutDirection">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Defines the direction in which the child widgets should be aligned.</a>
<a n="pDV">0</a>
<p:PC>
<a n="vertical">1</a>
<a n="horizontal">0</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LayoutPolicyList">
<a n="fc">Layout</a>
<a n="fd">Adds the layout policy &quot;list layout&quot; mechanism to a widget</a>
<a n="frc">w:GtfAbstractVisualWidget&amp;&amp;!wf:LayoutPolicyAbsolute&amp;&amp;!wf:LayoutPolicyGrid&amp;&amp;!wf:LayoutPolicyBox&amp;&amp;!wf:LayoutPolicyFlow</a>
<p:fP>
<p:p n="layoutDirection">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Defines the direction in which the list items should be aligned.</a>
<a n="pDV">1</a>
<p:PC>
<a n="vertical">1</a>
<a n="horizontal">0</a>
</p:PC>
</p:p>
<p:p n="scrollOffset">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Current scroll offset starting from scrollIndex.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="scrollOffsetRebase">
<a n="pT">0</a>
<a n="pC">Layout policy</a>
<a n="pD">Rebases property scrollOffset, scrollIndex will be updated accordingly.</a>
<a n="pDV">false</a>
</p:p>
<p:p n="firstListIndex">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">List index of first visible list item.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="scrollIndex">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">List index which is used as origin for scrollOffset.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="scrollValue">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Current scroll value.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="scrollValueMax">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Maximum scroll value.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="scrollValueMin">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Minimum scroll value.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="bounceValue">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Current bouncing value at beginning or end position.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="bounceValueMax">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Max bouncing value at beginning or end position.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="segments">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Number of columns or rows depending on layout direction.</a>
<a n="pDV">1</a>
</p:p>
<p:p n="listLength">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">Number of list items.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="wrapAround">
<a n="pT">0</a>
<a n="pC">Layout policy</a>
<a n="pD">Enables wrap around on beginning and end of list.</a>
<a n="pDV">false</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LayoutPolicyListItem">
<a n="fc">List management</a>
<a n="fd">This feature is intended for usage in combination with the &quot;Layout Policy List&quot;. By activation a list item index variable will be added to the widget.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="listIndex">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">List index of this list item.</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LayoutMargins">
<a n="fc">Layout</a>
<a n="fd">This feature extends the auto layout policies with configurable margins</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="leftMargin">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The left margin between the widget border and the children.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="topMargin">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The top margin between the widget border and the children.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="rightMargin">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The right margin between the widget border and the children.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="bottomMargin">
<a n="pT">7</a>
<a n="pC">Layout policy</a>
<a n="pD">The bottom margin between the widget border and the children.</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Multistate">
<a n="fc">Common</a>
<a n="fd">Only the content of one child will be visible at this time</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="containerIndex">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">Index to the children of the container. </a>
<a n="pDV">0</a>
</p:p>
<p:p n="containerMapping">
<a n="pT">22</a>
<a n="pC">Appearance</a>
<a n="pD">If a mapping is set, each child of the container will be readdressed by its appropriated value in &quot;containerMapping&quot;.</a>
<a n="pDV"/>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Buttongroup">
<a n="fc">Common</a>
<a n="fd">Only one button in a group of widgets with this feature can be selected at any time</a>
<a n="frc">wf:StateSelected</a>
<p:fP>
<p:p n="buttonId">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The identifier of the button within a button array.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="buttonValue">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The current value of the button. If this value matches the &quot;buttonId&quot;, the button is selected.</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Rotarybutton">
<a n="fc">Common</a>
<a n="fd">Adds a reaction to special increment / decrement events on an internal value. This widget may be used to create a scale or a widget with a preview value</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="currentValue">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The current rotary value.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="maxValue">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The maximum border value for &quot;currentValue&quot;.</a>
<a n="pDV">100</a>
</p:p>
<p:p n="minValue">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The minimum border value for &quot;currentValue&quot;.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="incValueTrigger">
<a n="pT">0</a>
<a n="pC">Event</a>
<a n="pD">This slot requires a message with a parameter: Message (Integer param). &quot;currentValue&quot; will be incremented by &quot;param&quot;. If a common GUIDE event has been set, param is defined as &quot;+1&quot;..</a>
<a n="pDV">false</a>
</p:p>
<p:p n="incValueReaction">
<a n="pT">123</a>
<a n="pC">Event</a>
<a n="pD">Slot to define a related &quot;next out&quot; event to &quot;next in&quot;  event.</a>
<a n="pDV">function(){}</a>
</p:p>
<p:p n="decValueTrigger">
<a n="pT">0</a>
<a n="pC">Event</a>
<a n="pD">This slot requires a message with a parameter: Message (Integer param). &quot;currentValue&quot; will be decremented by &quot;param&quot;. If a common GUIDE event has been set, param is defined as &quot;-1&quot;..</a>
<a n="pDV">false</a>
</p:p>
<p:p n="decValueReaction">
<a n="pT">123</a>
<a n="pC">Event</a>
<a n="pD">Slot to define a related &quot;previous out&quot; event to &quot;previous in&quot;  event.</a>
<a n="pDV">function(){}</a>
</p:p>
<p:p n="steps">
<a n="pT">7</a>
<a n="pC">Appearance</a>
<a n="pD">The number of steps which is used to calculate the increment/decrement for &quot;currentValue&quot;.</a>
<a n="pDV">100</a>
</p:p>
<p:p n="valueWrapAround">
<a n="pT">0</a>
<a n="pC">Appearance</a>
<a n="pD">If true, &quot;currentValue&quot; should continue at the inverse border if &quot;minValue&quot; or &quot;maxValue&quot; has been exceeded. If false, &quot;currentValue&quot; will not decrease/increase if &quot;minValue&quot; or &quot;maxValue&quot; exceeded...</a>
<a n="pDV">false</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LineIndex">
<a n="fc">List management</a>
<a n="fd">This feature is intended for usage in combination with a Table widget. By activation a line index variable will be added to the widget. This variable may be used as data index for the current Table line.</a>
<a n="frc">w:GtfCustomEffect||w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="lineIndex">
<a n="pT">7</a>
<a n="pC">List management</a>
<a n="pD">Data index of the current Table line.</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="ViewPort">
<a n="fc">List management</a>
<a n="fd">This feature is intended for usage in combination with container or list widgets. It reduces the viewable range of children within the container to the containers dimensions.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="xOffset">
<a n="pT">7</a>
<a n="pC">Layout</a>
<a n="pD">Defines the horizontal offset of the visible clipping within the drawn child area.</a>
<a n="pDV">0</a>
</p:p>
<p:p n="yOffset">
<a n="pT">7</a>
<a n="pC">Layout</a>
<a n="pD">Defines the vertical offset of the visible clipping within the drawn child area.</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Moveable">
<a n="fc">Input handling</a>
<a n="fd">Provides the ability to move a widget directly by touch.</a>
<a n="frc">wf:StateTouched&amp;&amp;wf:TouchMove</a>
<p:fP>
<p:p n="moveDirection">
<a n="pT">7</a>
<a n="pC">Behavior</a>
<a n="pD">Defines the direction in which the widget can be moved.</a>
<a n="pDV">2</a>
<p:PC>
<a n="vertical">1</a>
<a n="free">2</a>
<a n="horizontal">0</a>
</p:PC>
</p:p>
</p:fP>
</p:wf>
<p:wf n="LineTemplateIndex">
<a n="fc">List management</a>
<a n="fd">This feature is intended for usage in combination with an instantiator widget. By activation a line template index variable will be added to the widget. This variable indicates the how-manyeth instance of the template the widget is.</a>
<a n="frc">w:GtfCustomEffect||w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="lineTemplateIndex">
<a n="pT">7</a>
<a n="pC">List management</a>
<a n="pD">Instance number of the used line template.</a>
<a n="pDV">0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Coloration">
<a n="fc">Effect</a>
<a n="fd">Colors the widget.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="colorationEnabled">
<a n="pT">0</a>
<a n="pC">Coloration</a>
<a n="pD">This flag defines if the coloration is enabled or not.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="colorationColor">
<a n="pT">28</a>
<a n="pC">Coloration</a>
<a n="pD">The color of the coloration</a>
<a n="pDV">255, 255, 255, 255</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Translation">
<a n="fc">Transformation</a>
<a n="fd">Moves the widget.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="translationEnabled">
<a n="pT">0</a>
<a n="pC">Transformation</a>
<a n="pD">This flag defines if the translation is enabled or not.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="translationX">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The translation in units in X direction</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="translationY">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The translation in units in Y direction</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="translationZ">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The translation in units in Z direction</a>
<a n="pDV">0.0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Rotation">
<a n="fc">Transformation</a>
<a n="fd">Rotates the widget by its axes in degree.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="rotationEnabled">
<a n="pT">0</a>
<a n="pC">Transformation</a>
<a n="pD">This flag defines if the rotation is enabled or not.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="rotationAngleX">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The rotation around the x-axis in degree</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="rotationAngleY">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The rotation around the y-axis in degree</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="rotationAngleZ">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The rotation around the z-axis in degree</a>
<a n="pDV">0.0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Scaling">
<a n="fc">Transformation</a>
<a n="fd">Scales the widget by its axes in percent.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="scalingEnabled">
<a n="pT">0</a>
<a n="pC">Transformation</a>
<a n="pD">This flag defines if the scaling is enabled or not.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="scalingX">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The scaling in percent in X direction</a>
<a n="pDV">100</a>
</p:p>
<p:p n="scalingY">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The scaling in percent in Y direction</a>
<a n="pDV">100</a>
</p:p>
<p:p n="scalingZ">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The scaling in percent in Z direction</a>
<a n="pDV">100</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Shearing">
<a n="fc">Transformation</a>
<a n="fd">Shears the widget by the given parameters.</a>
<a n="frc">w:GtfAbstractVisualWidget</a>
<p:fP>
<p:p n="shearingEnabled">
<a n="pT">0</a>
<a n="pC">Transformation</a>
<a n="pD">This flag defines if the shearing is enabled or not.</a>
<a n="pDV">true</a>
</p:p>
<p:p n="shearingXbyY">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The shearing in percent x by y</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="shearingXbyZ">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The shearing in percent x by z</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="shearingYbyX">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The shearing in percent y by x</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="shearingYbyZ">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The shearing in percent y by z</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="shearingZbyX">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The shearing in percent z by x</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="shearingZbyY">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The shearing in percent z by y</a>
<a n="pDV">0.0</a>
</p:p>
</p:fP>
</p:wf>
<p:wf n="Pivot">
<a n="fc">Transformation</a>
<a n="fd">A fixed point for rotation, scaling and shearing transformations.</a>
<a n="frc">wf:Rotation||wf:Scaling||wf:Shearing</a>
<p:fP>
<p:p n="pivotX">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The x coordinate of the fixed point</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="pivotY">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The y coordinate of the fixed point</a>
<a n="pDV">0.0</a>
</p:p>
<p:p n="pivotZ">
<a n="pT">9</a>
<a n="pC">Transformation</a>
<a n="pD">The z coordinate of the fixed point</a>
<a n="pDV">0.0</a>
</p:p>
</p:fP>
</p:wf>
</p:WF>
</pl>
